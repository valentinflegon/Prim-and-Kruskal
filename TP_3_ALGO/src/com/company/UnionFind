package com.company;



import java.awt.*;
import java.util.ArrayList;
import java.util.HashMap;

/**
 * Partie 2 du TP Prim via UnionFind avec tas
 */
public class UnionFind {
    public Graph graph;
    public Path[] paths;
    public int[] parent;

    public UnionFind(Graph graph){
        this.graph = graph;
        parent = new int[graph.arrayListOfNode.size()];
        initialisePaths();
        initialiseParent();
    }

    public boolean PrimUnionFind(){
        boolean flag;
        Path tmpPath;
        int i;
        do {
            flag = false;
            i = 0;
            tmpPath = null;
            do {
                System.out.println(i + "eee" +parent[i]);
                for (Path path : graph.arrayListOfNode.get(i).getArrayOfPath()){
                    if ((tmpPath == null || tmpPath.getWeight() > path.getWeight()) && parent[path.getEnd().getIndex()] == path.getEnd().getIndex() && !isPointedInParent(path.getEnd().getIndex()))
                        tmpPath = path;
                }
                if (parent[i] == i) flag = true;
                i = parent[i];
                System.out.println("boucle parent : " + i + parent[i]);
                displayParent();
            }while (!flag);
            if (tmpPath == null)return false;
            System.out.println(tmpPath.getBegin().getIndex() + "eee" + tmpPath.getWeight() + "aaa" + tmpPath.getEnd().getIndex());
            parent[i] = tmpPath.getEnd().getIndex();
            setTrue(tmpPath);
        }while (!isValid());
        return true;
    }

    public boolean kruskalUnionFind(){
        int endNodePosition, beginNodePosition;
        for (Path path:paths) {
            if (isValid())return true;
            endNodePosition = path.getEnd().getIndex();
            beginNodePosition = path.getBegin().getIndex();
            if (parent[endNodePosition] == endNodePosition) {
                parent[endNodePosition] = beginNodePosition;
                setTrue(path);
            }else if(!isLinked(beginNodePosition, endNodePosition)){
                setNewRootInParent(beginNodePosition, endNodePosition);
                setTrue(path);
            }
        }
        return false;
    }

    public boolean isValid(){
        int flag = 0;

        for (int i = 0; i < parent.length; i++){
            if (i == parent[i]){
                flag++;
                if (flag > 1)return false;
            }
        }
        return true;
    }

    private void initialiseParent(){
        for (int i = 0; i < parent.length; i++){
            parent[i] = i;
        }
    }

    private void initialisePaths(){
        ArrayList<Path> pathArrayList = new ArrayList<>();
        for (Node node:graph.arrayListOfNode) {
            for (int pathPosition = 0; pathPosition < node.getArrayOfPath().size(); pathPosition++){
                if (!pathArrayList.contains(node.getArrayOfPath().get(pathPosition))) {
                    pathArrayList.add(node.getArrayOfPath().get(pathPosition));
                }
            }
            //node.setKeyValue(Integer.MAX_VALUE);
        }
        paths = new Path[pathArrayList.size()];
        int i = 0;
        for (Path path : pathArrayList) {
            paths[i] = path;
            i++;
        }
        bubbleSort();
    }

    private void setTrue(Path path){
        graph.arrayListOfNode.get(graph.arrayListOfNode.indexOf(path.getEnd())).getArrayOfPath().get(graph.arrayListOfNode.get(graph.arrayListOfNode.indexOf(path.getEnd())).getArrayOfPath().indexOf(path)).setVariableIsUsed(true);
        path.setVariableIsUsed(true);
        path.getEnd().setUsed(true);
        path.getBegin().setUsed(true);
        path.getEnd().getArrayOfPath().get(path.getEnd().getArrayOfPath().indexOf(path)).setVariableIsUsed(true);
        path.getBegin().getArrayOfPath().get(path.getBegin().getArrayOfPath().indexOf(path)).setVariableIsUsed(true);
    }

    private boolean isLinked(int firstInteger, int secondInteger) {
        int i = firstInteger;
        while (parent[i] == i) {
            i = parent[i];
        }
        int j = secondInteger;
        while (parent[j] == j) {
            j = parent[j];
        }
        if (j == i)return true;
        else return false;
    }

    private void setNewRootInParent(int firstInteger, int secondInteger){
        int j = secondInteger;
        while (parent[j] == j) {
            j = parent[j];
        }
        parent[j]=firstInteger;
    }
    public void bubbleSort() {
        int n = paths.length;
        for (int i = 0; i < n-1; i++)
            for (int j = 0; j < n-i-1; j++)
                if (paths[j].getWeight() > paths[j+1].getWeight())
                {
                    Path temp = paths[j];
                    paths[j] = paths[j+1];
                    paths[j+1] = temp;
                }
    }

    public void displayParent(){
        for (int i = 0; i < parent.length; i++) {
            System.out.println(i + ": parent : " + parent[i]);
        }
    }

    public boolean isPointedInParent(int i){
        for (int j = 0; j < parent.length; j++){
            if(i != j && parent[j] == i)return true;
        }
        return false;
    }
}

